%\VignetteIndexEntry{RiVIERA}
%
\documentclass[12pt]{article}

\usepackage[left=1in,top=1in,right=1in, bottom=1in]{geometry}

\usepackage{Sweave}
\usepackage{times}
\usepackage{hyperref}
\usepackage{subfig}
\usepackage{natbib}
\usepackage{graphicx}


\hypersetup{ 
colorlinks,
citecolor=black,
filecolor=black, 
linkcolor=black, 
urlcolor=black 
}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\textsf{R}}

\newcommand{\model}{\software{RiVIERA-MT}}

\newcommand{\bs}{\boldsymbol}
\newcommand{\mf}{\mathbf}
\newcommand{\fig}{Fig.}

\setkeys{Gin}{height=0.6\textheight}

\bibliographystyle{plain}

\title{RiVIERA-MT: Risk Variants Inference using Epigenomic Reference Annotations to predict Multiple Trait-causing colocalized mutations}
\author{Yue Li \\ \texttt{liyue@mit.edu}}
\date{\today}


\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle

\section{\model}


<<loadmypkg, eval=TRUE>>=
library(RiVIERA)
@

\section{Brief introduction}
\model~is or a full Bayesian framework to fine-map causal variants using GWAS summary statistics in z-scores in one or multiple related traits and large-scale reference annotations in binary or continuous values \cite{Li:2016mt}. The goal of RiVIERA is to infer for each SNP in disease their posterior probability of disease association and to detect functional enrichments or depletions from the annotations, taking into account the underlying multi-trait epigenomic covariance.

\section{Data preparation}
To run \model, we will need three types of data: 

\begin{enumerate}
\item GWAS summary statistics in a nested list of of Z-scores variants for at least one single trait
\item Linkage disequilibrium (LD) either from the GWAS cohort or reference panel (e.g. 1000 Genome consortium)
\item Functional annotation matrix (binary or continuous) for each SNP
\end{enumerate}

For illustration purpose, we provide a simulated dataset saved in RData file and loaded as follows:

<<simdata, eval=TRUE>>=
load(system.file("extdata/sim_seed103.RData", package="RiVIERA"))
# load("~/Projects/riviera/RiVIERA/inst/extdata/sim_seed103.RData")
sel <- which(simdata$causalcnt > 0)
zscoreList <- list(do.call(rbind, simdata$gwasZval[sel]))
ldmatList <- list(simdata$hapr2[sel])
annList <- list(do.call(rbind, simdata$ann[sel]))
locusCursorList <- list(get_locusCursors(simdata$hapr2[sel]))
@
where the \texttt{get\_locusCursors} generate the start and end positions of the SNP in the zscore matrix. Please become familiar with format of the input to able to process your own data the way. We also provide a wrapper function that takes a set of text files and process them into the require inputs (TO-DO).


To train the model and infer causal variants, simply issue the following command:

<<train, eval=TRUE, echo=TRUE>>=
set.seed(23)
res <- riviera(
  zscoreList,
  ldmatList,
  annList,
  locusCursorList,
  gwasize=matrix(1e4),
  causalCntPerLocus=1,
  pve_max = 1,
  max_iter =100,
  inferPIP_freq=10,
  samplePVE_freq=10,
  useAnn = TRUE,
  sampleConfig_iter=10,
  step = 0.01,
  nsteps = 100,
  printfreq = 10,
  verbose = T)
burnFrac <- 0.2
burnIdx <- 1:round(burnFrac * length(res$pipList_ensemble))
pred <- averagePIP(res$pipList_ensemble[-burnIdx])[[1]]
# pred <- zscoreList[[1]]
rownames(pred) <- rownames(zscoreList[[1]])
@

We now visualize the finemapping results in 3 representative loci in the plots below. In the first scenario, the risk locus harbors one causal variant (red cricle), which drives the genetic signals of other non-causal variants via linkage disequilibrium (LD). Notably, the lead SNP (dark diamond) with the most significant p-value is not the causal variant. In this case scenario, the underlying epigenomic activities (middle track) provide a crucial evidence to the inference of functional variants. Methods that assume single causal variant per locus may work well here by normalizing the posterior for each SNP within the locus \cite{Pickrell:2014bw,Farh:2015ka}. However, these methods become inadequate when there are more than one causal variant within the same locus (\fig~\ref{fig:example}b,c) because they will pull down the true signals of all causal variants in order to maintain a properly normalized posterior probabilities.

For instance, \fig~\ref{fig:ldm2},\ref{fig:vizfm2} and \fig~\ref{fig:ldm3},\ref{fig:vizfm3} illustrate two loci containing 3 and as many as 10 causal variants in the same loci, respectively. In these cases, our \model~model is still able to efficiently infer the correct PIP by marginalizing over a large number of sampled causal configurations with high local posteriors, which automatically accounts for the potentially large number of causal variants within the same locus without predefining the number of causal variants per locus.

<<vizfm, eval=TRUE, echo=FALSE>>=
library(ggplot2)
library(ggbio)
library(GenomicRanges)
library(LDheatmap)
library(gridExtra)

source(system.file("extdata/gwasvis.R", package="RiVIERA"))
source(system.file("extdata/plotfun.R", package="RiVIERA"))

ggman_list <- ggann_list <- 
  ggpip_list  <- locusRange_list <- ggbio_tracks_list <- list()

block_list <- c(27,69,23)

for(block_b in block_list) {
  
  ggman <- gwasvis_helper(simdata, block_b)
  
  ggpip <- gwasvis_helper(simdata, block_b, 
                          pred = pred, predOnly = T)
  
  ann_b <- as.data.frame(simdata$ann[[block_b]])
  
  ann_b$rsid <- rownames(ann_b)
  
  pos <- start(simdata$snpGRlist[[block_b]])
  
  names(pos) <- simdata$snpidByBlocks[[block_b]]
  
  causal_pos_b <- pos[names(pos) %in% simdata$causal_snpid]
  
  ann_b$pos <- pos
  
  ann_b <- melt(ann_b, id.vars=c("rsid", "pos"))
  
  ann_b <- subset(ann_b, value > 0)
  
  ann_b$ann[ann_b$value == 1] <- 
    sub(".pval.signal.bigwig.RData","",ann_b$variable[ann_b$value == 1])
  
  gr_sel <- simdata$snpGRlist[[block_b]]
  
  chrom <- as.character(seqnames(gr_sel))[1]
  
  locusRange <- sprintf("%s: %s-%s", chrom, min(start(gr_sel)), max(end(gr_sel)))
  
  ggann <- ggplot(ann_b, aes(x=pos, color=ann, weight=value)) + 
    
    theme_bw() + 
    
    geom_density(stat='bin', position='stack') +
    
    geom_vline(xintercept=causal_pos_b, color="red", alpha=0.2, size=2) +
    
    theme(legend.position="none") +
    
    ylab("Epigenomic activities") + xlab(locusRange)
  
  x <- simdata$hapr2[[block_b]]
  
  dimnames(x) <- list(pos, pos)
  
  ldf <- melt(x)
  
  locusRange_list[[as.character(block_b)]] <- locusRange
  
  ggbio_tracks <- tracks(ggman,
                         ggann,
                         ggpip,
                         xlab=locusRange)
  
  ggbio_tracks_list[[as.character(block_b)]] <- ggbio_tracks
  
  ggman_list[[as.character(block_b)]] <- ggman
  ggann_list[[as.character(block_b)]] <- ggann
  ggpip_list[[as.character(block_b)]] <- ggpip  
}
@

% locus 1
<<setlocus, eval=TRUE, echo=FALSE>>=
b <- 1
@

\begin{figure}[htbp]
<<ldm1, eval=TRUE, fig=TRUE, echo=FALSE>>=
block_b <- block_list[[b]]
idx <- as.character(block_b)
pos <- start(simdata$snpGRlist[[block_b]])
names(pos) <- simdata$snpidByBlocks[[block_b]]
x <- simdata$hapr2[[block_b]]
dimnames(x) <- list(names(pos),names(pos))
causal_pos_b <- pos[names(pos) %in% simdata$causal_snpid]
LDheatmap(x, pos, flip=T, color=heat.colors(20),
          SNP.name = names(causal_pos_b),
          title="", newpage=TRUE)
@
\caption{Linkage disequilibrium on Locus 1.}
\label{fig:ldm1}
\end{figure}
\begin{figure}[htbp]
<<vizPlots1, eval=TRUE, fig=TRUE, echo=FALSE>>=
block_b <- block_list[[b]]
idx <- as.character(block_b)
pos <- start(simdata$snpGRlist[[block_b]])
names(pos) <- simdata$snpidByBlocks[[block_b]]
x <- simdata$hapr2[[block_b]]
dimnames(x) <- list(names(pos),names(pos))
ggbio_tracks_list[[idx]]
@
\caption{Fine-mapping visualization on Locus 1.}
\label{fig:vizfm1}
\end{figure}




% locus 2
<<setlocus, eval=TRUE, echo=FALSE>>=
b <- 2
@

\begin{figure}[htbp]
<<ldm2, eval=TRUE, fig=TRUE, echo=FALSE>>=
block_b <- block_list[[b]]
idx <- as.character(block_b)
pos <- start(simdata$snpGRlist[[block_b]])
names(pos) <- simdata$snpidByBlocks[[block_b]]
x <- simdata$hapr2[[block_b]]
dimnames(x) <- list(names(pos),names(pos))
causal_pos_b <- pos[names(pos) %in% simdata$causal_snpid]
LDheatmap(x, pos, flip=T, color=heat.colors(20),
          SNP.name = names(causal_pos_b),
          title="", newpage=TRUE)
@
\caption{Linkage disequilibrium on Locus 2.}
\label{fig:ldm2}
\end{figure}
\begin{figure}[htbp]
<<vizPlots2, eval=TRUE, fig=TRUE, echo=FALSE>>=
block_b <- block_list[[b]]
idx <- as.character(block_b)
pos <- start(simdata$snpGRlist[[block_b]])
names(pos) <- simdata$snpidByBlocks[[block_b]]
x <- simdata$hapr2[[block_b]]
dimnames(x) <- list(names(pos),names(pos))
ggbio_tracks_list[[idx]]
@
\caption{Fine-mapping visualization on Locus 2.}
\label{fig:vizfm2}
\end{figure}



% locus 3
<<setlocus, eval=TRUE, echo=FALSE>>=
b <- 3
@
\begin{figure}[htbp]
<<ldm3, eval=TRUE, fig=TRUE, echo=FALSE>>=
block_b <- block_list[[b]]
idx <- as.character(block_b)
pos <- start(simdata$snpGRlist[[block_b]])
names(pos) <- simdata$snpidByBlocks[[block_b]]
x <- simdata$hapr2[[block_b]]
dimnames(x) <- list(names(pos),names(pos))
causal_pos_b <- pos[names(pos) %in% simdata$causal_snpid]
LDheatmap(x, pos, flip=T, color=heat.colors(20),
          SNP.name = names(causal_pos_b),
          title="", newpage=TRUE)
@
\caption{Linkage disequilibrium on Locus 3.}
\label{fig:ldm3}
\end{figure}
\begin{figure}[htbp]
<<vizPlots3, eval=TRUE, fig=TRUE, echo=FALSE>>=
block_b <- block_list[[b]]
idx <- as.character(block_b)
pos <- start(simdata$snpGRlist[[block_b]])
names(pos) <- simdata$snpidByBlocks[[block_b]]
x <- simdata$hapr2[[block_b]]
dimnames(x) <- list(names(pos),names(pos))
ggbio_tracks_list[[idx]]
@
\caption{Fine-mapping visualization on Locus 3.}
\label{fig:vizfm3}
\end{figure}






\section{Session Info}
<<sessi>>=
sessionInfo()
@


\bibliography{RiVIERA}
\end{document}

















